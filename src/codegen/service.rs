// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.BlockID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockID {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.BlockID.height)
    pub height: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.BlockID.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.BlockID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockID {
    fn default() -> &'a BlockID {
        <BlockID as ::protobuf::Message>::default_instance()
    }
}

impl BlockID {
    pub fn new() -> BlockID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BlockID| { &m.height },
            |m: &mut BlockID| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockID| { &m.hash },
            |m: &mut BlockID| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockID>(
            "BlockID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockID {
    const NAME: &'static str = "BlockID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_uint64()?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.height);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockID {
        BlockID::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockID {
        static instance: BlockID = BlockID {
            height: 0,
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.BlockRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockRange {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.BlockRange.start)
    pub start: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.BlockRange.end)
    pub end: ::protobuf::MessageField<BlockID>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.BlockRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRange {
    fn default() -> &'a BlockRange {
        <BlockRange as ::protobuf::Message>::default_instance()
    }
}

impl BlockRange {
    pub fn new() -> BlockRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "start",
            |m: &BlockRange| { &m.start },
            |m: &mut BlockRange| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "end",
            |m: &BlockRange| { &m.end },
            |m: &mut BlockRange| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRange>(
            "BlockRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRange {
    const NAME: &'static str = "BlockRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRange {
        BlockRange::new()
    }

    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRange {
        static instance: BlockRange = BlockRange {
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.TxFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TxFilter {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TxFilter.block)
    pub block: ::protobuf::MessageField<BlockID>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TxFilter.index)
    pub index: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TxFilter.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.TxFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TxFilter {
    fn default() -> &'a TxFilter {
        <TxFilter as ::protobuf::Message>::default_instance()
    }
}

impl TxFilter {
    pub fn new() -> TxFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockID>(
            "block",
            |m: &TxFilter| { &m.block },
            |m: &mut TxFilter| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &TxFilter| { &m.index },
            |m: &mut TxFilter| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TxFilter| { &m.hash },
            |m: &mut TxFilter| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TxFilter>(
            "TxFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TxFilter {
    const NAME: &'static str = "TxFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                16 => {
                    self.index = is.read_uint64()?;
                },
                26 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.index);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.index != 0 {
            os.write_uint64(2, self.index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(3, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TxFilter {
        TxFilter::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.index = 0;
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TxFilter {
        static instance: TxFilter = TxFilter {
            block: ::protobuf::MessageField::none(),
            index: 0,
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TxFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TxFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TxFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.RawTransaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RawTransaction {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.RawTransaction.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.RawTransaction.height)
    pub height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.RawTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RawTransaction {
    fn default() -> &'a RawTransaction {
        <RawTransaction as ::protobuf::Message>::default_instance()
    }
}

impl RawTransaction {
    pub fn new() -> RawTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &RawTransaction| { &m.data },
            |m: &mut RawTransaction| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &RawTransaction| { &m.height },
            |m: &mut RawTransaction| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RawTransaction>(
            "RawTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RawTransaction {
    const NAME: &'static str = "RawTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RawTransaction {
        RawTransaction::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RawTransaction {
        static instance: RawTransaction = RawTransaction {
            data: ::std::vec::Vec::new(),
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RawTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RawTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RawTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.SendResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SendResponse {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.SendResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.SendResponse.errorMessage)
    pub errorMessage: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.SendResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendResponse {
    fn default() -> &'a SendResponse {
        <SendResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendResponse {
    pub fn new() -> SendResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &SendResponse| { &m.errorCode },
            |m: &mut SendResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorMessage",
            |m: &SendResponse| { &m.errorMessage },
            |m: &mut SendResponse| { &mut m.errorMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendResponse>(
            "SendResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendResponse {
    const NAME: &'static str = "SendResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errorCode = is.read_int32()?;
                },
                18 => {
                    self.errorMessage = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errorCode);
        }
        if !self.errorMessage.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errorMessage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errorCode != 0 {
            os.write_int32(1, self.errorCode)?;
        }
        if !self.errorMessage.is_empty() {
            os.write_string(2, &self.errorMessage)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendResponse {
        SendResponse::new()
    }

    fn clear(&mut self) {
        self.errorCode = 0;
        self.errorMessage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendResponse {
        static instance: SendResponse = SendResponse {
            errorCode: 0,
            errorMessage: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.ChainSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChainSpec {
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.ChainSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainSpec {
    fn default() -> &'a ChainSpec {
        <ChainSpec as ::protobuf::Message>::default_instance()
    }
}

impl ChainSpec {
    pub fn new() -> ChainSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChainSpec>(
            "ChainSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChainSpec {
    const NAME: &'static str = "ChainSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainSpec {
        ChainSpec::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainSpec {
        static instance: ChainSpec = ChainSpec {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChainSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChainSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChainSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.Empty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Empty {
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.Empty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Empty>(
            "Empty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Empty {
    const NAME: &'static str = "Empty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Empty {
        static instance: Empty = Empty {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Empty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Empty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.LightdInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LightdInfo {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.vendor)
    pub vendor: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.taddrSupport)
    pub taddrSupport: bool,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.chainName)
    pub chainName: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.saplingActivationHeight)
    pub saplingActivationHeight: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.consensusBranchId)
    pub consensusBranchId: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.blockHeight)
    pub blockHeight: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.gitCommit)
    pub gitCommit: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.branch)
    pub branch: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.buildDate)
    pub buildDate: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.buildUser)
    pub buildUser: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.estimatedHeight)
    pub estimatedHeight: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.zcashdBuild)
    pub zcashdBuild: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.LightdInfo.zcashdSubversion)
    pub zcashdSubversion: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.LightdInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LightdInfo {
    fn default() -> &'a LightdInfo {
        <LightdInfo as ::protobuf::Message>::default_instance()
    }
}

impl LightdInfo {
    pub fn new() -> LightdInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &LightdInfo| { &m.version },
            |m: &mut LightdInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor",
            |m: &LightdInfo| { &m.vendor },
            |m: &mut LightdInfo| { &mut m.vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "taddrSupport",
            |m: &LightdInfo| { &m.taddrSupport },
            |m: &mut LightdInfo| { &mut m.taddrSupport },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chainName",
            |m: &LightdInfo| { &m.chainName },
            |m: &mut LightdInfo| { &mut m.chainName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "saplingActivationHeight",
            |m: &LightdInfo| { &m.saplingActivationHeight },
            |m: &mut LightdInfo| { &mut m.saplingActivationHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "consensusBranchId",
            |m: &LightdInfo| { &m.consensusBranchId },
            |m: &mut LightdInfo| { &mut m.consensusBranchId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockHeight",
            |m: &LightdInfo| { &m.blockHeight },
            |m: &mut LightdInfo| { &mut m.blockHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gitCommit",
            |m: &LightdInfo| { &m.gitCommit },
            |m: &mut LightdInfo| { &mut m.gitCommit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "branch",
            |m: &LightdInfo| { &m.branch },
            |m: &mut LightdInfo| { &mut m.branch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buildDate",
            |m: &LightdInfo| { &m.buildDate },
            |m: &mut LightdInfo| { &mut m.buildDate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buildUser",
            |m: &LightdInfo| { &m.buildUser },
            |m: &mut LightdInfo| { &mut m.buildUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "estimatedHeight",
            |m: &LightdInfo| { &m.estimatedHeight },
            |m: &mut LightdInfo| { &mut m.estimatedHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zcashdBuild",
            |m: &LightdInfo| { &m.zcashdBuild },
            |m: &mut LightdInfo| { &mut m.zcashdBuild },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zcashdSubversion",
            |m: &LightdInfo| { &m.zcashdSubversion },
            |m: &mut LightdInfo| { &mut m.zcashdSubversion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightdInfo>(
            "LightdInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightdInfo {
    const NAME: &'static str = "LightdInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                18 => {
                    self.vendor = is.read_string()?;
                },
                24 => {
                    self.taddrSupport = is.read_bool()?;
                },
                34 => {
                    self.chainName = is.read_string()?;
                },
                40 => {
                    self.saplingActivationHeight = is.read_uint64()?;
                },
                50 => {
                    self.consensusBranchId = is.read_string()?;
                },
                56 => {
                    self.blockHeight = is.read_uint64()?;
                },
                66 => {
                    self.gitCommit = is.read_string()?;
                },
                74 => {
                    self.branch = is.read_string()?;
                },
                82 => {
                    self.buildDate = is.read_string()?;
                },
                90 => {
                    self.buildUser = is.read_string()?;
                },
                96 => {
                    self.estimatedHeight = is.read_uint64()?;
                },
                106 => {
                    self.zcashdBuild = is.read_string()?;
                },
                114 => {
                    self.zcashdSubversion = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.vendor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vendor);
        }
        if self.taddrSupport != false {
            my_size += 1 + 1;
        }
        if !self.chainName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.chainName);
        }
        if self.saplingActivationHeight != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.saplingActivationHeight);
        }
        if !self.consensusBranchId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.consensusBranchId);
        }
        if self.blockHeight != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.blockHeight);
        }
        if !self.gitCommit.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.gitCommit);
        }
        if !self.branch.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.branch);
        }
        if !self.buildDate.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.buildDate);
        }
        if !self.buildUser.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.buildUser);
        }
        if self.estimatedHeight != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.estimatedHeight);
        }
        if !self.zcashdBuild.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.zcashdBuild);
        }
        if !self.zcashdSubversion.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.zcashdSubversion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.vendor.is_empty() {
            os.write_string(2, &self.vendor)?;
        }
        if self.taddrSupport != false {
            os.write_bool(3, self.taddrSupport)?;
        }
        if !self.chainName.is_empty() {
            os.write_string(4, &self.chainName)?;
        }
        if self.saplingActivationHeight != 0 {
            os.write_uint64(5, self.saplingActivationHeight)?;
        }
        if !self.consensusBranchId.is_empty() {
            os.write_string(6, &self.consensusBranchId)?;
        }
        if self.blockHeight != 0 {
            os.write_uint64(7, self.blockHeight)?;
        }
        if !self.gitCommit.is_empty() {
            os.write_string(8, &self.gitCommit)?;
        }
        if !self.branch.is_empty() {
            os.write_string(9, &self.branch)?;
        }
        if !self.buildDate.is_empty() {
            os.write_string(10, &self.buildDate)?;
        }
        if !self.buildUser.is_empty() {
            os.write_string(11, &self.buildUser)?;
        }
        if self.estimatedHeight != 0 {
            os.write_uint64(12, self.estimatedHeight)?;
        }
        if !self.zcashdBuild.is_empty() {
            os.write_string(13, &self.zcashdBuild)?;
        }
        if !self.zcashdSubversion.is_empty() {
            os.write_string(14, &self.zcashdSubversion)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightdInfo {
        LightdInfo::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.vendor.clear();
        self.taddrSupport = false;
        self.chainName.clear();
        self.saplingActivationHeight = 0;
        self.consensusBranchId.clear();
        self.blockHeight = 0;
        self.gitCommit.clear();
        self.branch.clear();
        self.buildDate.clear();
        self.buildUser.clear();
        self.estimatedHeight = 0;
        self.zcashdBuild.clear();
        self.zcashdSubversion.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightdInfo {
        static instance: LightdInfo = LightdInfo {
            version: ::std::string::String::new(),
            vendor: ::std::string::String::new(),
            taddrSupport: false,
            chainName: ::std::string::String::new(),
            saplingActivationHeight: 0,
            consensusBranchId: ::std::string::String::new(),
            blockHeight: 0,
            gitCommit: ::std::string::String::new(),
            branch: ::std::string::String::new(),
            buildDate: ::std::string::String::new(),
            buildUser: ::std::string::String::new(),
            estimatedHeight: 0,
            zcashdBuild: ::std::string::String::new(),
            zcashdSubversion: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightdInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightdInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LightdInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightdInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.TransparentAddressBlockFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransparentAddressBlockFilter {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TransparentAddressBlockFilter.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TransparentAddressBlockFilter.range)
    pub range: ::protobuf::MessageField<BlockRange>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.TransparentAddressBlockFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransparentAddressBlockFilter {
    fn default() -> &'a TransparentAddressBlockFilter {
        <TransparentAddressBlockFilter as ::protobuf::Message>::default_instance()
    }
}

impl TransparentAddressBlockFilter {
    pub fn new() -> TransparentAddressBlockFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &TransparentAddressBlockFilter| { &m.address },
            |m: &mut TransparentAddressBlockFilter| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockRange>(
            "range",
            |m: &TransparentAddressBlockFilter| { &m.range },
            |m: &mut TransparentAddressBlockFilter| { &mut m.range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransparentAddressBlockFilter>(
            "TransparentAddressBlockFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransparentAddressBlockFilter {
    const NAME: &'static str = "TransparentAddressBlockFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.range)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if let Some(v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if let Some(v) = self.range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransparentAddressBlockFilter {
        TransparentAddressBlockFilter::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.range.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransparentAddressBlockFilter {
        static instance: TransparentAddressBlockFilter = TransparentAddressBlockFilter {
            address: ::std::string::String::new(),
            range: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransparentAddressBlockFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransparentAddressBlockFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransparentAddressBlockFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransparentAddressBlockFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.Duration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Duration {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.Duration.intervalUs)
    pub intervalUs: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.Duration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Duration {
    fn default() -> &'a Duration {
        <Duration as ::protobuf::Message>::default_instance()
    }
}

impl Duration {
    pub fn new() -> Duration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intervalUs",
            |m: &Duration| { &m.intervalUs },
            |m: &mut Duration| { &mut m.intervalUs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Duration>(
            "Duration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Duration {
    const NAME: &'static str = "Duration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.intervalUs = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.intervalUs != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.intervalUs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.intervalUs != 0 {
            os.write_int64(1, self.intervalUs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Duration {
        Duration::new()
    }

    fn clear(&mut self) {
        self.intervalUs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Duration {
        static instance: Duration = Duration {
            intervalUs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Duration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Duration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Duration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Duration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.PingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingResponse {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.PingResponse.entry)
    pub entry: i64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.PingResponse.exit)
    pub exit: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entry",
            |m: &PingResponse| { &m.entry },
            |m: &mut PingResponse| { &mut m.entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exit",
            |m: &PingResponse| { &m.exit },
            |m: &mut PingResponse| { &mut m.exit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entry = is.read_int64()?;
                },
                16 => {
                    self.exit = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.entry != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.entry);
        }
        if self.exit != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.exit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.entry != 0 {
            os.write_int64(1, self.entry)?;
        }
        if self.exit != 0 {
            os.write_int64(2, self.exit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.entry = 0;
        self.exit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            entry: 0,
            exit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Address {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.Address.address)
    pub address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Address| { &m.address },
            |m: &mut Address| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Address>(
            "Address",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Address {
    const NAME: &'static str = "Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Address {
        Address::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Address {
        static instance: Address = Address {
            address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Address {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.AddressList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressList {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.AddressList.addresses)
    pub addresses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.AddressList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressList {
    fn default() -> &'a AddressList {
        <AddressList as ::protobuf::Message>::default_instance()
    }
}

impl AddressList {
    pub fn new() -> AddressList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &AddressList| { &m.addresses },
            |m: &mut AddressList| { &mut m.addresses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressList>(
            "AddressList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressList {
    const NAME: &'static str = "AddressList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressList {
        AddressList::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressList {
        static instance: AddressList = AddressList {
            addresses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.Balance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Balance {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.Balance.valueZat)
    pub valueZat: i64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.Balance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Balance {
    fn default() -> &'a Balance {
        <Balance as ::protobuf::Message>::default_instance()
    }
}

impl Balance {
    pub fn new() -> Balance {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "valueZat",
            |m: &Balance| { &m.valueZat },
            |m: &mut Balance| { &mut m.valueZat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Balance>(
            "Balance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Balance {
    const NAME: &'static str = "Balance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.valueZat = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.valueZat != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.valueZat);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.valueZat != 0 {
            os.write_int64(1, self.valueZat)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Balance {
        Balance::new()
    }

    fn clear(&mut self) {
        self.valueZat = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Balance {
        static instance: Balance = Balance {
            valueZat: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Balance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Balance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Balance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Balance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.Exclude)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Exclude {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.Exclude.txid)
    pub txid: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.Exclude.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Exclude {
    fn default() -> &'a Exclude {
        <Exclude as ::protobuf::Message>::default_instance()
    }
}

impl Exclude {
    pub fn new() -> Exclude {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "txid",
            |m: &Exclude| { &m.txid },
            |m: &mut Exclude| { &mut m.txid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exclude>(
            "Exclude",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Exclude {
    const NAME: &'static str = "Exclude";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.txid {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.txid {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Exclude {
        Exclude::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Exclude {
        static instance: Exclude = Exclude {
            txid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Exclude {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Exclude").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Exclude {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exclude {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.TreeState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TreeState {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.network)
    pub network: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.height)
    pub height: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.time)
    pub time: u32,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.saplingTree)
    pub saplingTree: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.TreeState.orchardTree)
    pub orchardTree: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.TreeState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TreeState {
    fn default() -> &'a TreeState {
        <TreeState as ::protobuf::Message>::default_instance()
    }
}

impl TreeState {
    pub fn new() -> TreeState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network",
            |m: &TreeState| { &m.network },
            |m: &mut TreeState| { &mut m.network },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &TreeState| { &m.height },
            |m: &mut TreeState| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TreeState| { &m.hash },
            |m: &mut TreeState| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &TreeState| { &m.time },
            |m: &mut TreeState| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "saplingTree",
            |m: &TreeState| { &m.saplingTree },
            |m: &mut TreeState| { &mut m.saplingTree },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orchardTree",
            |m: &TreeState| { &m.orchardTree },
            |m: &mut TreeState| { &mut m.orchardTree },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TreeState>(
            "TreeState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TreeState {
    const NAME: &'static str = "TreeState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.network = is.read_string()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                26 => {
                    self.hash = is.read_string()?;
                },
                32 => {
                    self.time = is.read_uint32()?;
                },
                42 => {
                    self.saplingTree = is.read_string()?;
                },
                50 => {
                    self.orchardTree = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.time);
        }
        if !self.saplingTree.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.saplingTree);
        }
        if !self.orchardTree.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.orchardTree);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        if self.time != 0 {
            os.write_uint32(4, self.time)?;
        }
        if !self.saplingTree.is_empty() {
            os.write_string(5, &self.saplingTree)?;
        }
        if !self.orchardTree.is_empty() {
            os.write_string(6, &self.orchardTree)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TreeState {
        TreeState::new()
    }

    fn clear(&mut self) {
        self.network.clear();
        self.height = 0;
        self.hash.clear();
        self.time = 0;
        self.saplingTree.clear();
        self.orchardTree.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TreeState {
        static instance: TreeState = TreeState {
            network: ::std::string::String::new(),
            height: 0,
            hash: ::std::string::String::new(),
            time: 0,
            saplingTree: ::std::string::String::new(),
            orchardTree: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TreeState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TreeState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TreeState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.GetSubtreeRootsArg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSubtreeRootsArg {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetSubtreeRootsArg.startIndex)
    pub startIndex: u32,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetSubtreeRootsArg.shieldedProtocol)
    pub shieldedProtocol: ::protobuf::EnumOrUnknown<ShieldedProtocol>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetSubtreeRootsArg.maxEntries)
    pub maxEntries: u32,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.GetSubtreeRootsArg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSubtreeRootsArg {
    fn default() -> &'a GetSubtreeRootsArg {
        <GetSubtreeRootsArg as ::protobuf::Message>::default_instance()
    }
}

impl GetSubtreeRootsArg {
    pub fn new() -> GetSubtreeRootsArg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "startIndex",
            |m: &GetSubtreeRootsArg| { &m.startIndex },
            |m: &mut GetSubtreeRootsArg| { &mut m.startIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shieldedProtocol",
            |m: &GetSubtreeRootsArg| { &m.shieldedProtocol },
            |m: &mut GetSubtreeRootsArg| { &mut m.shieldedProtocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maxEntries",
            |m: &GetSubtreeRootsArg| { &m.maxEntries },
            |m: &mut GetSubtreeRootsArg| { &mut m.maxEntries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSubtreeRootsArg>(
            "GetSubtreeRootsArg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSubtreeRootsArg {
    const NAME: &'static str = "GetSubtreeRootsArg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.startIndex = is.read_uint32()?;
                },
                16 => {
                    self.shieldedProtocol = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.maxEntries = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.startIndex != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.startIndex);
        }
        if self.shieldedProtocol != ::protobuf::EnumOrUnknown::new(ShieldedProtocol::sapling) {
            my_size += ::protobuf::rt::int32_size(2, self.shieldedProtocol.value());
        }
        if self.maxEntries != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.maxEntries);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.startIndex != 0 {
            os.write_uint32(1, self.startIndex)?;
        }
        if self.shieldedProtocol != ::protobuf::EnumOrUnknown::new(ShieldedProtocol::sapling) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.shieldedProtocol))?;
        }
        if self.maxEntries != 0 {
            os.write_uint32(3, self.maxEntries)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSubtreeRootsArg {
        GetSubtreeRootsArg::new()
    }

    fn clear(&mut self) {
        self.startIndex = 0;
        self.shieldedProtocol = ::protobuf::EnumOrUnknown::new(ShieldedProtocol::sapling);
        self.maxEntries = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSubtreeRootsArg {
        static instance: GetSubtreeRootsArg = GetSubtreeRootsArg {
            startIndex: 0,
            shieldedProtocol: ::protobuf::EnumOrUnknown::from_i32(0),
            maxEntries: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSubtreeRootsArg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSubtreeRootsArg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSubtreeRootsArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubtreeRootsArg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.SubtreeRoot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubtreeRoot {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.SubtreeRoot.rootHash)
    pub rootHash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.SubtreeRoot.completingBlockHash)
    pub completingBlockHash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.SubtreeRoot.completingBlockHeight)
    pub completingBlockHeight: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.SubtreeRoot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubtreeRoot {
    fn default() -> &'a SubtreeRoot {
        <SubtreeRoot as ::protobuf::Message>::default_instance()
    }
}

impl SubtreeRoot {
    pub fn new() -> SubtreeRoot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rootHash",
            |m: &SubtreeRoot| { &m.rootHash },
            |m: &mut SubtreeRoot| { &mut m.rootHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completingBlockHash",
            |m: &SubtreeRoot| { &m.completingBlockHash },
            |m: &mut SubtreeRoot| { &mut m.completingBlockHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completingBlockHeight",
            |m: &SubtreeRoot| { &m.completingBlockHeight },
            |m: &mut SubtreeRoot| { &mut m.completingBlockHeight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubtreeRoot>(
            "SubtreeRoot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubtreeRoot {
    const NAME: &'static str = "SubtreeRoot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.rootHash = is.read_bytes()?;
                },
                26 => {
                    self.completingBlockHash = is.read_bytes()?;
                },
                32 => {
                    self.completingBlockHeight = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rootHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.rootHash);
        }
        if !self.completingBlockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.completingBlockHash);
        }
        if self.completingBlockHeight != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.completingBlockHeight);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rootHash.is_empty() {
            os.write_bytes(2, &self.rootHash)?;
        }
        if !self.completingBlockHash.is_empty() {
            os.write_bytes(3, &self.completingBlockHash)?;
        }
        if self.completingBlockHeight != 0 {
            os.write_uint64(4, self.completingBlockHeight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubtreeRoot {
        SubtreeRoot::new()
    }

    fn clear(&mut self) {
        self.rootHash.clear();
        self.completingBlockHash.clear();
        self.completingBlockHeight = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubtreeRoot {
        static instance: SubtreeRoot = SubtreeRoot {
            rootHash: ::std::vec::Vec::new(),
            completingBlockHash: ::std::vec::Vec::new(),
            completingBlockHeight: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubtreeRoot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubtreeRoot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubtreeRoot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubtreeRoot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.GetAddressUtxosArg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAddressUtxosArg {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosArg.addresses)
    pub addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosArg.startHeight)
    pub startHeight: u64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosArg.maxEntries)
    pub maxEntries: u32,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.GetAddressUtxosArg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAddressUtxosArg {
    fn default() -> &'a GetAddressUtxosArg {
        <GetAddressUtxosArg as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressUtxosArg {
    pub fn new() -> GetAddressUtxosArg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &GetAddressUtxosArg| { &m.addresses },
            |m: &mut GetAddressUtxosArg| { &mut m.addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "startHeight",
            |m: &GetAddressUtxosArg| { &m.startHeight },
            |m: &mut GetAddressUtxosArg| { &mut m.startHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maxEntries",
            |m: &GetAddressUtxosArg| { &m.maxEntries },
            |m: &mut GetAddressUtxosArg| { &mut m.maxEntries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAddressUtxosArg>(
            "GetAddressUtxosArg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAddressUtxosArg {
    const NAME: &'static str = "GetAddressUtxosArg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_string()?);
                },
                16 => {
                    self.startHeight = is.read_uint64()?;
                },
                24 => {
                    self.maxEntries = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.startHeight != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.startHeight);
        }
        if self.maxEntries != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.maxEntries);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        if self.startHeight != 0 {
            os.write_uint64(2, self.startHeight)?;
        }
        if self.maxEntries != 0 {
            os.write_uint32(3, self.maxEntries)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAddressUtxosArg {
        GetAddressUtxosArg::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.startHeight = 0;
        self.maxEntries = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAddressUtxosArg {
        static instance: GetAddressUtxosArg = GetAddressUtxosArg {
            addresses: ::std::vec::Vec::new(),
            startHeight: 0,
            maxEntries: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAddressUtxosArg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAddressUtxosArg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAddressUtxosArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressUtxosArg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.GetAddressUtxosReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAddressUtxosReply {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.txid)
    pub txid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.index)
    pub index: i32,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.script)
    pub script: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.valueZat)
    pub valueZat: i64,
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.height)
    pub height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.GetAddressUtxosReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAddressUtxosReply {
    fn default() -> &'a GetAddressUtxosReply {
        <GetAddressUtxosReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressUtxosReply {
    pub fn new() -> GetAddressUtxosReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &GetAddressUtxosReply| { &m.address },
            |m: &mut GetAddressUtxosReply| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &GetAddressUtxosReply| { &m.txid },
            |m: &mut GetAddressUtxosReply| { &mut m.txid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &GetAddressUtxosReply| { &m.index },
            |m: &mut GetAddressUtxosReply| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "script",
            |m: &GetAddressUtxosReply| { &m.script },
            |m: &mut GetAddressUtxosReply| { &mut m.script },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "valueZat",
            |m: &GetAddressUtxosReply| { &m.valueZat },
            |m: &mut GetAddressUtxosReply| { &mut m.valueZat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetAddressUtxosReply| { &m.height },
            |m: &mut GetAddressUtxosReply| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAddressUtxosReply>(
            "GetAddressUtxosReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAddressUtxosReply {
    const NAME: &'static str = "GetAddressUtxosReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.address = is.read_string()?;
                },
                10 => {
                    self.txid = is.read_bytes()?;
                },
                16 => {
                    self.index = is.read_int32()?;
                },
                26 => {
                    self.script = is.read_bytes()?;
                },
                32 => {
                    self.valueZat = is.read_int64()?;
                },
                40 => {
                    self.height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.address);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.index);
        }
        if !self.script.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.script);
        }
        if self.valueZat != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.valueZat);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(6, &self.address)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.index != 0 {
            os.write_int32(2, self.index)?;
        }
        if !self.script.is_empty() {
            os.write_bytes(3, &self.script)?;
        }
        if self.valueZat != 0 {
            os.write_int64(4, self.valueZat)?;
        }
        if self.height != 0 {
            os.write_uint64(5, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAddressUtxosReply {
        GetAddressUtxosReply::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.txid.clear();
        self.index = 0;
        self.script.clear();
        self.valueZat = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAddressUtxosReply {
        static instance: GetAddressUtxosReply = GetAddressUtxosReply {
            address: ::std::string::String::new(),
            txid: ::std::vec::Vec::new(),
            index: 0,
            script: ::std::vec::Vec::new(),
            valueZat: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAddressUtxosReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAddressUtxosReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAddressUtxosReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressUtxosReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:cash.z.wallet.sdk.rpc.GetAddressUtxosReplyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAddressUtxosReplyList {
    // message fields
    // @@protoc_insertion_point(field:cash.z.wallet.sdk.rpc.GetAddressUtxosReplyList.addressUtxos)
    pub addressUtxos: ::std::vec::Vec<GetAddressUtxosReply>,
    // special fields
    // @@protoc_insertion_point(special_field:cash.z.wallet.sdk.rpc.GetAddressUtxosReplyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAddressUtxosReplyList {
    fn default() -> &'a GetAddressUtxosReplyList {
        <GetAddressUtxosReplyList as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressUtxosReplyList {
    pub fn new() -> GetAddressUtxosReplyList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addressUtxos",
            |m: &GetAddressUtxosReplyList| { &m.addressUtxos },
            |m: &mut GetAddressUtxosReplyList| { &mut m.addressUtxos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAddressUtxosReplyList>(
            "GetAddressUtxosReplyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAddressUtxosReplyList {
    const NAME: &'static str = "GetAddressUtxosReplyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addressUtxos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addressUtxos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addressUtxos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAddressUtxosReplyList {
        GetAddressUtxosReplyList::new()
    }

    fn clear(&mut self) {
        self.addressUtxos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAddressUtxosReplyList {
        static instance: GetAddressUtxosReplyList = GetAddressUtxosReplyList {
            addressUtxos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAddressUtxosReplyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAddressUtxosReplyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAddressUtxosReplyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressUtxosReplyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cash.z.wallet.sdk.rpc.ShieldedProtocol)
pub enum ShieldedProtocol {
    // @@protoc_insertion_point(enum_value:cash.z.wallet.sdk.rpc.ShieldedProtocol.sapling)
    sapling = 0,
    // @@protoc_insertion_point(enum_value:cash.z.wallet.sdk.rpc.ShieldedProtocol.orchard)
    orchard = 1,
}

impl ::protobuf::Enum for ShieldedProtocol {
    const NAME: &'static str = "ShieldedProtocol";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ShieldedProtocol> {
        match value {
            0 => ::std::option::Option::Some(ShieldedProtocol::sapling),
            1 => ::std::option::Option::Some(ShieldedProtocol::orchard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ShieldedProtocol> {
        match str {
            "sapling" => ::std::option::Option::Some(ShieldedProtocol::sapling),
            "orchard" => ::std::option::Option::Some(ShieldedProtocol::orchard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ShieldedProtocol] = &[
        ShieldedProtocol::sapling,
        ShieldedProtocol::orchard,
    ];
}

impl ::protobuf::EnumFull for ShieldedProtocol {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ShieldedProtocol").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ShieldedProtocol {
    fn default() -> Self {
        ShieldedProtocol::sapling
    }
}

impl ShieldedProtocol {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ShieldedProtocol>("ShieldedProtocol")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rservice.proto\x12\x15cash.z.wallet.sdk.rpc\x1a\x15compact_formats.pr\
    oto\"5\n\x07BlockID\x12\x16\n\x06height\x18\x01\x20\x01(\x04R\x06height\
    \x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\"t\n\nBlockRange\x124\n\
    \x05start\x18\x01\x20\x01(\x0b2\x1e.cash.z.wallet.sdk.rpc.BlockIDR\x05st\
    art\x120\n\x03end\x18\x02\x20\x01(\x0b2\x1e.cash.z.wallet.sdk.rpc.BlockI\
    DR\x03end\"j\n\x08TxFilter\x124\n\x05block\x18\x01\x20\x01(\x0b2\x1e.cas\
    h.z.wallet.sdk.rpc.BlockIDR\x05block\x12\x14\n\x05index\x18\x02\x20\x01(\
    \x04R\x05index\x12\x12\n\x04hash\x18\x03\x20\x01(\x0cR\x04hash\"<\n\x0eR\
    awTransaction\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x16\n\
    \x06height\x18\x02\x20\x01(\x04R\x06height\"P\n\x0cSendResponse\x12\x1c\
    \n\terrorCode\x18\x01\x20\x01(\x05R\terrorCode\x12\"\n\x0cerrorMessage\
    \x18\x02\x20\x01(\tR\x0cerrorMessage\"\x0b\n\tChainSpec\"\x07\n\x05Empty\
    \"\xf4\x03\n\nLightdInfo\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07ver\
    sion\x12\x16\n\x06vendor\x18\x02\x20\x01(\tR\x06vendor\x12\"\n\x0ctaddrS\
    upport\x18\x03\x20\x01(\x08R\x0ctaddrSupport\x12\x1c\n\tchainName\x18\
    \x04\x20\x01(\tR\tchainName\x128\n\x17saplingActivationHeight\x18\x05\
    \x20\x01(\x04R\x17saplingActivationHeight\x12,\n\x11consensusBranchId\
    \x18\x06\x20\x01(\tR\x11consensusBranchId\x12\x20\n\x0bblockHeight\x18\
    \x07\x20\x01(\x04R\x0bblockHeight\x12\x1c\n\tgitCommit\x18\x08\x20\x01(\
    \tR\tgitCommit\x12\x16\n\x06branch\x18\t\x20\x01(\tR\x06branch\x12\x1c\n\
    \tbuildDate\x18\n\x20\x01(\tR\tbuildDate\x12\x1c\n\tbuildUser\x18\x0b\
    \x20\x01(\tR\tbuildUser\x12(\n\x0festimatedHeight\x18\x0c\x20\x01(\x04R\
    \x0festimatedHeight\x12\x20\n\x0bzcashdBuild\x18\r\x20\x01(\tR\x0bzcashd\
    Build\x12*\n\x10zcashdSubversion\x18\x0e\x20\x01(\tR\x10zcashdSubversion\
    \"r\n\x1dTransparentAddressBlockFilter\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x127\n\x05range\x18\x02\x20\x01(\x0b2!.cash.z.wallet\
    .sdk.rpc.BlockRangeR\x05range\"*\n\x08Duration\x12\x1e\n\nintervalUs\x18\
    \x01\x20\x01(\x03R\nintervalUs\"8\n\x0cPingResponse\x12\x14\n\x05entry\
    \x18\x01\x20\x01(\x03R\x05entry\x12\x12\n\x04exit\x18\x02\x20\x01(\x03R\
    \x04exit\"#\n\x07Address\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07add\
    ress\"+\n\x0bAddressList\x12\x1c\n\taddresses\x18\x01\x20\x03(\tR\taddre\
    sses\"%\n\x07Balance\x12\x1a\n\x08valueZat\x18\x01\x20\x01(\x03R\x08valu\
    eZat\"\x1d\n\x07Exclude\x12\x12\n\x04txid\x18\x01\x20\x03(\x0cR\x04txid\
    \"\xa9\x01\n\tTreeState\x12\x18\n\x07network\x18\x01\x20\x01(\tR\x07netw\
    ork\x12\x16\n\x06height\x18\x02\x20\x01(\x04R\x06height\x12\x12\n\x04has\
    h\x18\x03\x20\x01(\tR\x04hash\x12\x12\n\x04time\x18\x04\x20\x01(\rR\x04t\
    ime\x12\x20\n\x0bsaplingTree\x18\x05\x20\x01(\tR\x0bsaplingTree\x12\x20\
    \n\x0borchardTree\x18\x06\x20\x01(\tR\x0borchardTree\"\xa9\x01\n\x12GetS\
    ubtreeRootsArg\x12\x1e\n\nstartIndex\x18\x01\x20\x01(\rR\nstartIndex\x12\
    S\n\x10shieldedProtocol\x18\x02\x20\x01(\x0e2'.cash.z.wallet.sdk.rpc.Shi\
    eldedProtocolR\x10shieldedProtocol\x12\x1e\n\nmaxEntries\x18\x03\x20\x01\
    (\rR\nmaxEntries\"\x91\x01\n\x0bSubtreeRoot\x12\x1a\n\x08rootHash\x18\
    \x02\x20\x01(\x0cR\x08rootHash\x120\n\x13completingBlockHash\x18\x03\x20\
    \x01(\x0cR\x13completingBlockHash\x124\n\x15completingBlockHeight\x18\
    \x04\x20\x01(\x04R\x15completingBlockHeight\"t\n\x12GetAddressUtxosArg\
    \x12\x1c\n\taddresses\x18\x01\x20\x03(\tR\taddresses\x12\x20\n\x0bstartH\
    eight\x18\x02\x20\x01(\x04R\x0bstartHeight\x12\x1e\n\nmaxEntries\x18\x03\
    \x20\x01(\rR\nmaxEntries\"\xa6\x01\n\x14GetAddressUtxosReply\x12\x18\n\
    \x07address\x18\x06\x20\x01(\tR\x07address\x12\x12\n\x04txid\x18\x01\x20\
    \x01(\x0cR\x04txid\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05index\x12\
    \x16\n\x06script\x18\x03\x20\x01(\x0cR\x06script\x12\x1a\n\x08valueZat\
    \x18\x04\x20\x01(\x03R\x08valueZat\x12\x16\n\x06height\x18\x05\x20\x01(\
    \x04R\x06height\"k\n\x18GetAddressUtxosReplyList\x12O\n\x0caddressUtxos\
    \x18\x01\x20\x03(\x0b2+.cash.z.wallet.sdk.rpc.GetAddressUtxosReplyR\x0ca\
    ddressUtxos*,\n\x10ShieldedProtocol\x12\x0b\n\x07sapling\x10\0\x12\x0b\n\
    \x07orchard\x10\x012\xe4\r\n\x11CompactTxStreamer\x12R\n\x0eGetLatestBlo\
    ck\x12\x20.cash.z.wallet.sdk.rpc.ChainSpec\x1a\x1e.cash.z.wallet.sdk.rpc\
    .BlockID\x12O\n\x08GetBlock\x12\x1e.cash.z.wallet.sdk.rpc.BlockID\x1a#.c\
    ash.z.wallet.sdk.rpc.CompactBlock\x12Y\n\x12GetBlockNullifiers\x12\x1e.c\
    ash.z.wallet.sdk.rpc.BlockID\x1a#.cash.z.wallet.sdk.rpc.CompactBlock\x12\
    W\n\rGetBlockRange\x12!.cash.z.wallet.sdk.rpc.BlockRange\x1a#.cash.z.wal\
    let.sdk.rpc.CompactBlock\x12a\n\x17GetBlockRangeNullifiers\x12!.cash.z.w\
    allet.sdk.rpc.BlockRange\x1a#.cash.z.wallet.sdk.rpc.CompactBlock\x12X\n\
    \x0eGetTransaction\x12\x1f.cash.z.wallet.sdk.rpc.TxFilter\x1a%.cash.z.wa\
    llet.sdk.rpc.RawTransaction\x12]\n\x0fSendTransaction\x12%.cash.z.wallet\
    .sdk.rpc.RawTransaction\x1a#.cash.z.wallet.sdk.rpc.SendResponse\x12o\n\
    \x10GetTaddressTxids\x124.cash.z.wallet.sdk.rpc.TransparentAddressBlockF\
    ilter\x1a%.cash.z.wallet.sdk.rpc.RawTransaction\x12X\n\x12GetTaddressBal\
    ance\x12\".cash.z.wallet.sdk.rpc.AddressList\x1a\x1e.cash.z.wallet.sdk.r\
    pc.Balance\x12Z\n\x18GetTaddressBalanceStream\x12\x1e.cash.z.wallet.sdk.\
    rpc.Address\x1a\x1e.cash.z.wallet.sdk.rpc.Balance\x12P\n\x0cGetMempoolTx\
    \x12\x1e.cash.z.wallet.sdk.rpc.Exclude\x1a\x20.cash.z.wallet.sdk.rpc.Com\
    pactTx\x12W\n\x10GetMempoolStream\x12\x1c.cash.z.wallet.sdk.rpc.Empty\
    \x1a%.cash.z.wallet.sdk.rpc.RawTransaction\x12P\n\x0cGetTreeState\x12\
    \x1e.cash.z.wallet.sdk.rpc.BlockID\x1a\x20.cash.z.wallet.sdk.rpc.TreeSta\
    te\x12T\n\x12GetLatestTreeState\x12\x1c.cash.z.wallet.sdk.rpc.Empty\x1a\
    \x20.cash.z.wallet.sdk.rpc.TreeState\x12`\n\x0fGetSubtreeRoots\x12).cash\
    .z.wallet.sdk.rpc.GetSubtreeRootsArg\x1a\".cash.z.wallet.sdk.rpc.Subtree\
    Root\x12m\n\x0fGetAddressUtxos\x12).cash.z.wallet.sdk.rpc.GetAddressUtxo\
    sArg\x1a/.cash.z.wallet.sdk.rpc.GetAddressUtxosReplyList\x12o\n\x15GetAd\
    dressUtxosStream\x12).cash.z.wallet.sdk.rpc.GetAddressUtxosArg\x1a+.cash\
    .z.wallet.sdk.rpc.GetAddressUtxosReply\x12P\n\rGetLightdInfo\x12\x1c.cas\
    h.z.wallet.sdk.rpc.Empty\x1a!.cash.z.wallet.sdk.rpc.LightdInfo\x12L\n\
    \x04Ping\x12\x1f.cash.z.wallet.sdk.rpc.Duration\x1a#.cash.z.wallet.sdk.r\
    pc.PingResponseB\x1bZ\x16lightwalletd/walletrpc\xba\x02\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::compact_formats::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(BlockID::generated_message_descriptor_data());
            messages.push(BlockRange::generated_message_descriptor_data());
            messages.push(TxFilter::generated_message_descriptor_data());
            messages.push(RawTransaction::generated_message_descriptor_data());
            messages.push(SendResponse::generated_message_descriptor_data());
            messages.push(ChainSpec::generated_message_descriptor_data());
            messages.push(Empty::generated_message_descriptor_data());
            messages.push(LightdInfo::generated_message_descriptor_data());
            messages.push(TransparentAddressBlockFilter::generated_message_descriptor_data());
            messages.push(Duration::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(Address::generated_message_descriptor_data());
            messages.push(AddressList::generated_message_descriptor_data());
            messages.push(Balance::generated_message_descriptor_data());
            messages.push(Exclude::generated_message_descriptor_data());
            messages.push(TreeState::generated_message_descriptor_data());
            messages.push(GetSubtreeRootsArg::generated_message_descriptor_data());
            messages.push(SubtreeRoot::generated_message_descriptor_data());
            messages.push(GetAddressUtxosArg::generated_message_descriptor_data());
            messages.push(GetAddressUtxosReply::generated_message_descriptor_data());
            messages.push(GetAddressUtxosReplyList::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ShieldedProtocol::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
